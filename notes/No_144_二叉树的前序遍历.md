# LeetCode No.144 二叉树的前序遍历

## 题目链接: https://leetcode.cn/problems/binary-tree-preorder-traversal/description/

## 题目描述
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。



## 解题思路
- ** 方法 1 ** ：递归
前序，就是中间节点在前，所以顺序是中左右。
中的方法是:result.append(cur.val)
左的方法是:help(cur.left,result)
右的方法是：help(cur.right,result)
结束条件是当cur为空就要返回去找
时间复杂度`O(N)`  
空间复杂度：`O(N)`

- ** 方法 2 ** ：遍历
前序，就是中间节点在前，所以顺序是中左右。
遍历的话是用stack栈实现，也就是先进后出，就符合python中list的操作方法。所以此时，因为顺序是中左右，所以对于中的话
中的方法是:
node= stack.pop()
result.append(node.val)
先弹出，然后直接加入result

左的方法是:
if node.right:
    stack.append(node.right)
因为后入的先出，所以我们想要让左边的node先出，需要先加入右边的节点，所以此时判断，如果有右边节点，那么才会加入。

右的方法是：
if node.left:
    stack.append(node.left)
与上同理。

时间复杂度`O(N)`  
空间复杂度：`O(N)`


- ** 方法 3 ** ：空指针遍历法：
这个方法是一个通用方法对于遍历树来说。
因为前面的方法对于前中后序的遍历来说有些不一样。因为根节点总是先被弹出的。这个方法是尽管弹出了根节点，但又按照顺序把根节点加进去了。但此时注意，要是反过来的压入栈中，因为是先进后出。然后这个其实是通过把遍历和处理分开了，先遍历当前节点，压入栈中。然后因为压入了一个None.所以下次就会变为处理的逻辑，所以就会从中拿到数据。
📌 [查看 Python 代码](../solutions/python/No_144_二叉树的前序遍历.py)