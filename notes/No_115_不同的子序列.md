# LeetCode No.115 不同的子序列

## 题目链接: https://leetcode.cn/problems/distinct-subsequences/description/

## 题目描述
给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。

测试用例保证结果在 32 位有符号整数范围内。
## 解题思路

- ** 方法 1 ** ：动态规划
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[i][j]的定义为：以i-1结尾的nums1，和以j-1结尾的nums2，的出现的个数。如果定义i，j结尾的话，那么下标0的情况不好定义。
2. 确定递推公式：
if nums1[i-1] == nums2[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
因为定义是nums1 的下标i-1,nums2的下标j-1所以对比是否相同。然后加上dp[i-1][j]也就是s可以回退一个，就是即使这个相同，我也不取他，看看前面有几个。
如果不等于就取和dp[i][j-1]也就是t数组的前一个，因为s字符串是要求的，比如说ace和abc. ac和abc对比。ace和ab进行对比，
else: dp[i][j] = dp[i-1][j],就是删除s的这个字符
3. dp数组如何初始化：
初始化的话，第一列要初始化为1，因为t是空，那么s不为空的话就是1个
第一行初始化为0，因为s为空的话，t不为空，那么就一个匹配的都没有。
dp[0][0]初始化为1，意味着空字符串中只有一个空字符串。
4. 确定遍历顺序：
从递推公式可以看出来,是从前向后遍历。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N^2)`

📌 [查看 Python 代码](../solutions/python/No_115_不同的子序列.py)