# 卡玛 97 小明逛公园

## 题目链接: https://kamacoder.com/problempage.php?pid=1155

## 题目描述
小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。 



给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。



小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。

输入描述
第一行包含两个整数 N, M, 分别表示景点的数量和道路的数量。 

接下来的 M 行，每行包含三个整数 u, v, w，表示景点 u 和景点 v 之间有一条长度为 w 的双向道路。 

接下里的一行包含一个整数 Q，表示观景计划的数量。 

接下来的 Q 行，每行包含两个整数 start, end，表示一个观景计划的起点和终点。

输出描述
对于每个观景计划，输出一行表示从起点到终点的最短路径长度。如果两个景点之间不存在路径，则输出 -1。
输入示例
7 3
2 3 4
3 6 6
4 7 8
2
2 3
3 4
输出示例
4
-1
## 解题思路
- ** 方法 1 ** ：Floyd 算法 + 三维数组+动态规划
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[i][j][k]:表示从i到j，经过[1-k]这个list中节点的最短路径长度。 

2. 确定递推公式：
dp[i][j][k] = min(dp[i][j][k-1], dp[i][k][k-1] + dp[k][j][k-1])
分为两种：
(1) 不经过k节点：dp[i][j][k-1]
(2) 经过k节点：dp[i][k][k-1] + dp[k][j][k-1]

3. dp数组如何初始化：
图先全部初始化为无穷大，然后根据输入的边的信息，初始化对应的边的距离。dp[start][end][0] = weight
4. 确定遍历顺序：
首先，初始化的是最低一层，也就是k为0的情况。然后从k=1开始，一直到k=N。每一层都需要遍历i和j，i和j从1到N。所以最外层是k,中间是i, 最内层是j。
5. 举例推导dp数组:
时间复杂度：`O(N^3 + Q)`，其中 N 是景点数量，Q 是观景计划数量。   
空间复杂度：`O(N^3)`，用于存储距离矩阵。

- ** 方法 2 ** ：Floyd 算法 + 二维数组+动态规划优化
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[i][j]:表示从i到j，经过[1-k]这个list中节点的最短路径长度。
2. 确定递推公式：
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
分为两种：
(1) 不经过k节点：dp[i][j]
(2) 经过k节点：dp[i][k] + dp[k][j]
3. dp数组如何初始化：
图先全部初始化为无穷大，然后根据输入的边的信息，初始化对应的边的距离。dp[start][end] = weight
4. 确定遍历顺序：
首先，初始化的是最低一层，也就是k为0的情况。然后从k=1开始，一直到k=N。每一层都需要遍历i和j，i和j从1到N。所以最外层是k,中间是i, 最内层是j。
5. 举例推导dp数组:
时间复杂度：`O(N^3 + Q)`，其中 N 是景点数量，Q 是观景计划数量。   
空间复杂度：`O(N^2)`，用于存储距离矩阵。

📌 [查看 Python 代码](../solutions/python/卡玛_97_小明逛公园.py)