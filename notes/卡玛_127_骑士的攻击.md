# 卡玛 127 骑士的攻击

## 题目链接: https://kamacoder.com/problempage.php?pid=1203

## 题目描述
在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。



棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）

输入描述
第一行包含一个整数 n，表示测试用例的数量，1 <= n <= 100。

接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。

输出描述
输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。
输入示例
6
5 2 5 4
1 1 2 2
1 1 8 8
1 1 8 7
2 1 3 3
4 6 4 6
输出示例
2
4
6
5
1
0
提示信息
骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。
## 解题思路
- ** 方法 1 ** ：A* 搜索算法
使用 A* 搜索算法来寻找骑士从起点到目标点的最短路径。A* 算法结合了广度优先搜索和启发式搜索的优点，通过估计从当前节点到目标节点的距离来指导搜索方向。具体步骤如下：
1. 定义骑士的八种可能移动方式。
2. 使用优先队列（最小堆）来存储待处理的节点，节点包含当前位置、已走步数和估计总步数（已走步数 + 启发式估计）。
3. 启发式函数使用曼哈顿距离来估计当前位置到目标位置的距离。
4. 从起点开始，依次处理优先队列中的节点，扩展其所有可能的移动位置，并将未访问过的位置加入队列。
5. 当到达目标位置时，返回已走步数   
首先，定义骑士的八种可能移动方式存入directions中。
其次，定义distance函数，计算当前位置到目标位置的欧拉几里得距离，作为启发式函数。
然后，用小根堆priority_queue存储待处理的节点，初始时将起点位置加入堆中，步数为0，估计总步数为启发式距离。
随后，遍历directions，计算骑士的下一个位置，如果该位置在棋盘范围内且未访问过，则计算新的步数和估计总步数，并将其加入堆中。在推入堆之前，计算启发式距离。也就是f(n) = g(n) + h(n)，其中g(n)是从起点到当前节点的实际代价，h(n)是从当前节点到目标节点的估计代价。这个作为第一个参数传入堆中，确保堆按照估计总步数排序。
最后，当处理到目标位置时，返回已走步数作为结果。如果堆为空且未找到目标位置，返回 -1 表示无法到达。
时间复杂度：在最坏情况下，A* 算法的时间复杂度为`O(b^d)`，其中 b 是每个节点的分支因子，d 是目标节点的深度。但由于启发式函数的引导，实际运行时间通常远小于此。    
空间复杂度：`O(N)`，用于存储访问过的位置。  

📌 [查看 Python 代码](../solutions/python/卡玛_127_骑士的攻击.py)