# LeetCode No.1049 最后一块石头的重量二

## 题目链接: https://leetcode.cn/problems/last-stone-weight-ii/description/

## 题目描述
有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。


## 解题思路
- ** 方法 1 ** ：动态规划一维数组：
一维数组的想法就是把二维压缩了，不存储上一层的数值了，而是用滚动数组，在一个数组中进行更新。
这道题的主要思想就是，为了让最后的石头最小，那么就可以把石头分成差不多的两堆，然后进行碰撞。总共的和是total_sum，然后第一堆的重量是vol = total_sum //2 .所以，第二堆的重量就是total_sum - dp[vol],第二堆肯定比第一堆大，所以最后答案是（total_sum - dp[vol]）-dp[vol]
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[j]的定义为：空间j的最大价值是dp[j].例如：dp[2]的含义是如果背包的容量为2，那么最大的价值就是dp[2]
2. 确定递推公式：
dp[j]有两种选择：
第一种，不放i物品进背包，那么此时它的值就是dp[j]也就是它上一格的值，也就意味着是不放i，那么最大的价值就是dp[j]

第二种，是放i进背包。那么此时的价值就是value[i] + dp[j-weight[i]]
这个的意思是，首先把i放进背包里了，所以，要value[i].随后，我们计算把i放进去还有多少空间，那么就是j-weight[i].那么就是此时的最大值。例如：当放了物品1之后，那么我们要加上物品1的值，然后如果物品1的空间是2，那么j-weight[i]就是剩余空间，那么剩余空间的最大值就是dp[j]
所以得到最后的公式
dp[j] = max(dp[j],value[i]+dp[j-weight[i]])
3. dp数组如何初始化：
dp数组只需要都初始化为0即可。因为空间不能是负数，所以最小的价值也就是0.
4. 确定遍历顺序：
这个遍历顺序非常有讲究，首先要先遍历物品，再遍历包的空间。因为首先要先遍历物品是因为，如果一旦先遍历了包的空间，那么久代表着每次这个空间只能使用一个物品，而不是多个物品。其次，最重要的是包的空间遍历需要从后到前，因为如果从前往后的话，dp[2]会需要dp[1]的值，如果此时遍历的是物品0，那么物品0在dp[1]的时候就放进去一次了，在dp[2]的时候又放进一次，就不符合题目要求了。所以要从后往前遍历，因为前面还没有遍历，所以后面的值尽管加上了前面的值也没关系。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N)` 

- ** 方法 12** ：动态规划二维数组：
同携带材料一样的二维数组

📌 [查看 Python 代码](../solutions/python/No_1049_最后一块石头的重量二.py)