# LeetCode No.416 分割等和子集

# 题目链接: https://leetcode.cn/problems/partition-equal-subset-sum/description/


## 题目描述
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

## 解题思路
- ** 方法 1 ** ：动态规划一维数组：
一维数组的想法就是把二维压缩了，不存储上一层的数值了，而是用滚动数组，在一个数组中进行更新。
这道题可以转换成01背包问题。那么首先先看是否和为偶数，如果是偶数才可能分割成两个子集的和相同。然后用01背包问题。看和的一半能否被填满，如果可以被填满，那么说明存在另一个子集也可以成为和的一半。
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[j]的定义为：空间j的最大价值是dp[j].例如：dp[2]的含义是如果背包的容量为2，那么最大的价值就是dp[2]。
2. 确定递推公式：
dp[j]有两种选择：
第一种，不放i物品进背包，那么此时它的值就是dp[j]也就是它上一格的值，也就意味着是不放i，那么最大的价值就是dp[j]

第二种，是放i进背包。那么此时的价值就是value[i] + dp[j-weight[i]]
这个的意思是，首先把i放进背包里了，所以，要value[i].随后，我们计算把i放进去还有多少空间，那么就是j-weight[i].那么就是此时的最大值。例如：当放了物品1之后，那么我们要加上物品1的值，然后如果物品1的空间是2，那么j-weight[i]就是剩余空间，那么剩余空间的最大值就是dp[j]
所以得到最后的公式
dp[j] = max(dp[j],value[i]+dp[j-weight[i]])
因为这是一个数组，所以value和weight都是nums[i]，因为它等于是重量和价值是一样的。而空间target。
3. dp数组如何初始化：
dp数组只需要都初始化为0即可。因为空间不能是负数，所以最小的价值也就是0.
4. 确定遍历顺序：
这个遍历顺序非常有讲究，首先要先遍历物品，再遍历包的空间。因为首先要先遍历物品是因为，如果一旦先遍历了包的空间，那么久代表着每次这个空间只能使用一个物品，而不是多个物品。其次，最重要的是包的空间遍历需要从后到前，因为如果从前往后的话，dp[2]会需要dp[1]的值，如果此时遍历的是物品0，那么物品0在dp[1]的时候就放进去一次了，在dp[2]的时候又放进一次，就不符合题目要求了。所以要从后往前遍历，因为前面还没有遍历，所以后面的值尽管加上了前面的值也没关系。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N)` 


📌 [查看 Python 代码](../solutions/python/No_416_分割等和子集.py)