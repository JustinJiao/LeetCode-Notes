# LeetCode No.005 最长回文子串

## 题目链接: https://leetcode.cn/problems/median-of-two-sorted-arrays/description/

## 题目描述
给你一个字符串 s，找到 s 中最长的 回文 子串。
## 解题思路
- ** 方法 1 ** ：中心扩展法
中心扩展法的思路是以每个字符为中心，向两边扩展，寻找回文子串。对于每个字符，我们需要考虑两种情况：以该字符为中心的回文子串（奇数长度）和以该字符和下一个字符之间为中心的回文子串（偶数长度）。在扩展过程中，我们需要检查左右两边的字符是否相等，如果相等则继续扩展，否则停止扩展。我们需要记录最长的回文子串的起始位置和长度，最后返回最长的回文子串。
时间复杂度`O(N^2)`  
空间复杂度：`O(1)`

- ** 方法 2 ** ：动态规划
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[i][j]的定义为：在[i,j]区间内是否为回文子串。True/False
2. 确定递推公式：
if s[i] == s[j]:当i和j是相邻的或者就是一个的话。那么就是回文子串。前题是这两个字符相等。还有就是离的很远，那么就看dp[i+1][j-1]是否是回文，如果是，那么扩展还是。
3. dp数组如何初始化：
全部初始化为False
4. 确定遍历顺序：
从递推公式可以看出来,确定dp[i+1][j-1]的时候需要左下角的格子。所以就从下到上，从左到右逐个添加。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N^2)`

📌 [查看 Python 代码](../solutions/python/No_005_最长回文子串.py)
