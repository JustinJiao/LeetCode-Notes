# LeetCode  No.76 最小覆盖子串

## 题目链接: https://leetcode.cn/problems/minimum-window-substring/description/

## 题目描述
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


## 解题思路
- ** 方法 1 ** ：双指针（滑动窗口）+哈希表
这道题的思路和之前找最小子串的思路一样。但是复杂的是加入了哈希表。这里要注意哈希表的用法。用一个check函数，直接用哈希表进行检查
时间复杂度`O(N)` check中尽管每次都循环，但是循环的最多也只有26个字符 
空间复杂度：`O(N)` 因为涉及到用两个哈希表

- ** 方法 2 ** ：双指针（滑动窗口）+哈希表（优化）
在方法一的基础上进行优化，减少check函数的时间复杂度。我们可以维护一个计数器来记录当前窗口中满足条件的字符数量。当满足条件的字符数量等于 t 中的字符数量时，我们就可以尝试缩小窗口，直到不满足条件为止。这样就避免了每次都需要遍历哈希表进行检查。
时间复杂度`O(N)`
空间复杂度：`O(N)` 因为涉及到用两个哈希表


📌 [查看 Python 代码](../solutions/python/No_076_最小覆盖子串.py)

