# LeetCode No.209 长度最小的子数组

## 题目链接: https://leetcode.cn/problems/minimum-size-subarray-sum/description/

## 题目描述
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

## 解题思路
- ** 方法 1 ** ：双指针（滑动窗口）：
这个方法是维护一个窗口：
窗口内需要满足和大于等于target
窗口的左指针位置移动：当前窗口内的值大于等于target的时候，左指针移动
窗口的右指针位置移动：窗口的右指针用来遍历数组
主要思想就是循环右指针，当右指针和左指针维护的窗口和大于target的时候，此时移动左指针，看看是否有更短的窗口满足。

时间复杂度`O(N)` 即使这个是两重循环，但并不是在每次右指针移动的时候都需要移动一遍左指针，所以右指针最多走N次，而左指针也最多走N次，所以最后的复杂度是2N。
空间复杂度：`O(1)`

- ** 方法 2 ** ：前缀和+二分查找：
这个方法有两个步骤：
1. 前缀和：维护一个sums的列表，这个列表存放着前n个元素的和，例如sums[i]的元素意味着在nums中前i个元素的和为sums[i]
2. 在sums中遍历，寻找符合目标的区间。从sums[1]开始，因为sums[0]的值为0，也就是从nums中的第一个元素开始，然后用二分法找到左边界，也就意味着找到最短的包含nums中第一个数字的区间。然后，去除掉前i个元素，寻找除了前i个元素之外的最短区间，直到去除所有元素。然后返回最短区间

时间复杂度`O(NlogN)` 因为维护一个前缀和的列表需要N，然后在遍历前缀和列表的时候，要考虑去除每一个元素，所以是N，而在确保去除前i个元素的同时又需要二分法来寻找每一个符合的区间，二分法需要Logn.所以最后需要nlogn
空间复杂度：`O(1)`

📌 [查看 Python 代码](../solutions/python/No_209_长度最小的子数组.py)