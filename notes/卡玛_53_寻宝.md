# 卡玛 53 寻宝

## 题目链接: https://kamacoder.com/problempage.php?pid=1053

## 题目描述
在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。

不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。 

给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。

输入描述
第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。

接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。

输出描述
输出联通所有岛屿的最小路径总距离
输入示例
7 11
1 2 1
1 3 1
1 5 2
2 6 1
2 4 2
2 3 2
3 4 1
4 5 1
5 6 2
5 7 1
6 7 1
输出示例
6
## 解题思路
- ** 方法 1 ** ：邻接矩阵 + Prim算法
使用邻接矩阵存储图的信息，然后使用 Prim 算法来计算最小生成树的总权值。首先初始化一个数组来记录每个节点到当前生成树的最小距离，然后不断选择距离生成树最近的节点，将其加入生成树，并更新其他节点的距离。重复这个过程直到所有节点都被加入生成树。最后返回最小生成树的总权值。
三部曲：
1. 第一步，选距离生成树最近节点
2. 第二步，最近节点加入生成树
3. 第三步，更新非生成树节点到生成树的距离（即更新minDist数组）

时间复杂度：`O(n^2)`，其中 n 是节点数量。   
空间复杂度：`O(n^2)`，用于存储

- ** 方法 2 ** ：并查集 + Kruskal算法
使用并查集（Union-Find）数据结构来处理图的连通性问题。首先将所有边按照权值从小到大排序，然后依次遍历每条边，尝试将连接的节点进行合并。如果两个节点已经在同一个集合中，说明添加这条边会形成环，跳过这条边。否则，将这条边加入最小生成树，并更新总权值。重复这个过程直到最小生成树包含所有节点。最后返回最小生成树的总权值。
时间复杂度：`O(E log E)`，其中 E 是边的数量。  
空间复杂度：`O(V)`，用于存储并查集的父节点和秩信息。

如果稠密图，使用 Prim 算法更合适；如果稀疏图，使用 Kruskal 算法更合适。

📌 [查看 Python 代码](../solutions/python/卡玛_53_寻宝.py)