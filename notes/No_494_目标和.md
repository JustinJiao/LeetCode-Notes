# LeetCode No.494 目标和

# 题目链接: https://leetcode.cn/problems/target-sum/description/


## 题目描述
给你一个非负整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

## 解题思路
- ** 方法 1 ** ：动态规划二维数组：
这道题的思路是首先每个数字可以有两个状态，一个+一个-。那么我们可以根据这个把数组划分为两个子数组，一个子数组前面的符号全为+，一个子数组前面的符号全为-。那么两个规定加数组为bagV 减数组为right.那么我们就有了
bagV - right = target
bagV + right = sum
2bagV = target + sum
bagV = (target + sum) /2
那么我们现在的想法就是求出bagV为容量有多少种方式了。
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[i][j]的定义为：可选的物品有0-i，在0-i种随意搭配组合，在空间j的情况下，可以有多少种不同的搭配选择。例如：dp[2][4]意思是随意搭配物品0，1，2在空间4中，共有dp[2][4]种选择。
2. 确定递推公式：
dp[i][j]有两种选择：
第一种，不放i物品进背包，那么此时它的值就是dp[i-1][j]也就是它上一格的值，也就意味着是不放i，那么就有[i-1][j]种选择

第二种，是放i进背包。那么久需要先空出物品i的容量，也就是j-nums[i],然后放满剩余的背包就是dp[i-1][j-nums[i]]
这个的意思是，先看i占多少空间，然后剩余的空间肯定不包括i，那么久看i-1在剩余空间中最大的值。
所以得到最后的公式
dp[i][j] = dp[i][j] + dp[i-1][j-nums[i]]
3. dp数组如何初始化：
首先确定在空间0的时候有1种方法，就是什么都不放，也就是bagV = []然后剩下的所有都在right中。所以dp[0][0]就是1.
所以最左侧因为是体积为0，那么就要看此时有几个0.比如说物品0，物品1，物品二都是0，那么此时就有2^3种可以满足。所以最左侧的数值是要取决于当前检索的物品有多少个0.
然后需要确定最上面一行的数值，那么此时就要看物品0的体积了，如果体积小于bagV中，那么dp[0][bagV] =1其余都是0.
4. 确定遍历顺序：
从递推公式可以看出来，dp[i][j]是从上一行和左列推倒出来的，所以要先完成上面一行，和左边一列才可以推出。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N^2)` 

- ** 方法 2 ** ：动态规划一维数组：
一维数组的想法就是把二维压缩了，不存储上一层的数值了，而是用滚动数组，在一个数组中进行更新。
这道题可以转换成01背包问题。同上
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[j]的定义为：空间为j的时候有dp[j]种方式.例如：dp[2]的含义是如果背包的容量为2，那么有dp[2]种方式。
2. 确定递推公式：
递推公式如上所述，去掉i的维度得到，所以是dp[j] = dp[j] +dp[j-nums[i]]
3. dp数组如何初始化：
dp[0]初始为1
4. 确定遍历顺序：
这个遍历顺序非常有讲究，首先要先遍历物品，再遍历包的空间。因为首先要先遍历物品是因为，如果一旦先遍历了包的空间，那么久代表着每次这个空间只能使用一个物品，而不是多个物品。其次，最重要的是包的空间遍历需要从后到前，因为如果从前往后的话，dp[2]会需要dp[1]的值，如果此时遍历的是物品0，那么物品0在dp[1]的时候就放进去一次了，在dp[2]的时候又放进一次，就不符合题目要求了。所以要从后往前遍历，因为前面还没有遍历，所以后面的值尽管加上了前面的值也没关系。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N)` 

📌 [查看 Python 代码](../solutions/python/No_416_分割等和子集.py)