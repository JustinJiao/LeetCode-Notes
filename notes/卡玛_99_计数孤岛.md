# 卡玛 99 计数孤岛

## 题目链接: https://kamacoder.com/problempage.php?pid=1171

## 题目描述
题目描述
给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。

输入描述
第一行包含两个整数 N, M，表示矩阵的行数和列数。

后续 N 行，每行包含 M 个数字，数字为 1 或者 0。

输出描述
输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。

输入示例
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1

输出示例
3
## 解题思路
- ** 方法 1 ** ：邻接矩阵 + 深度优先搜索（DFS）
这道题可以利用深度优先搜索（DFS）来遍历所有路径，使用邻接矩阵存储图的信息。
将图直接copy进去，然后遍历每一个节点。如果当前节点是陆地（1），则进行深度优先搜索，将与之相连的所有陆地节点标记为已访问（True），并将岛屿数量加一。
dfs函数中，检查当前节点是否为陆地（1），如果是，则将其标记为已访问（True），然后递归调用dfs函数，探索其上下左右四个方向的邻接节点。
深度搜索三部曲：
1.在递归函数中，检查当前节点是否为目标节点 n，如果是，则将当前路径加入结果列表中
2.遍历当前节点的所有邻接节点，递归调用函数，继续探索路径
3.回溯，移除当前节点，继续探索其他路径
时间复杂度：`O(V + E)`，其中 V 是节点数，E 是边数
空间复杂度：`O(V)`，用于存储邻接矩阵和递归栈

- ** 方法 2 ** ：邻接矩阵 + 广度优先搜索（BFS）
这道题也可以利用广度优先搜索（BFS）来遍历所有路径，使用邻接矩阵存储图的信息。
将图直接copy进去，然后遍历每一个节点。如果当前节点是陆地（1），则进行广度优先搜索，将与之相连的所有陆地节点标记为已访问（True），并将岛屿数量加一。
bfs函数中，使用队列来存储待访问的节点，依次访问每个节点的上下左右四个方向的邻接节点。
时间复杂度：`O(V + E)`，其中 V 是节点数，E 是边数
空间复杂度：`O(V)`，用于存储邻接矩阵和队列

📌 [查看 Python 代码](../solutions/python/卡玛_99_计数孤岛.py)