# 卡玛 102 沉没孤岛

## 题目链接: https://kamacoder.com/problempage.php?pid=1174

## 题目描述
题目描述
给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。



现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。

输入描述
第一行包含两个整数 N, M，表示矩阵的行数和列数。

之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。

输出描述
输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格
输入示例
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
输出示例
1 1 0 0 0
1 1 0 0 0
0 0 0 0 0
0 0 0 1 1
## 解题思路
- ** 方法 1 ** ：邻接矩阵 + 深度优先搜索（DFS）
这道题可以利用深度优先搜索（DFS）来遍历所有路径，使用邻接矩阵存储图的信息。
将图直接copy进去，然后遍历每一个节点。如果当前节点是陆地（1），则进行深度优先搜索，将与之相连的所有陆地节点标记为已访问（True），并将岛屿数量加一。
dfs函数中，检查当前节点是否为陆地（1），如果是，则将其标记为已访问（True），然后递归调用dfs函数，探索其上下左右四个方向的邻接节点。dfs函数返回当前岛屿的面积。在每次访问新的陆地节点时，更新最大面积。
dfs中返回两个参数，一个是是否closed，一个是cor节点。如果不closed，那么就不计入面积。   
深度搜索三部曲：
1.在递归函数中，检查当前节点是否为目标节点 n，如果是，则将当前路径加入结果列表中
2.遍历当前节点的所有邻接节点，递归调用函数，继续探索路径
3.回溯，移除当前节点，继续探索其他路径
时间复杂度：`O(V + E)`，其中 V 是节点数，E 是边数
空间复杂度：`O(V)`，用于存储邻接矩阵和递归栈



📌 [查看 Python 代码](../solutions/python/卡玛_102_沉没孤岛.py)