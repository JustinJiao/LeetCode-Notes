# LeetCode No.79 单词搜索

## 题目链接: https://leetcode.cn/problems/word-search/description/
## 题目描述
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
## 解题思路
- ** 方法 1 ** ：递归回溯+dfs
本题用dfs来解，dfs的三部曲
1.dfs传入的参数是当前节点的坐标和k，k意味着当前已经匹配过了word[k]
2.终止条件：如果k等于len(word)-1，说明已经匹配成功了，返回true；
3.单层搜索逻辑：从当前节点的上下左右四个方向进行搜索，判断是否越界，判断当前节点的字符是否等于word[k+1]，如果不等于就返回false，如果等于就继续往下搜索。为了防止重复访问，把当前节点标记为访问过，然后进行dfs，最后再把当前节点恢复原状。
外层直接从遍历board的每个节点开始进行dfs，如果有一个节点返回true，就说明找到了，直接返回true。 
时间复杂度：`O(M*N*4^L)`，其中M和N分别是board的行数和列数，L是word的长度。最坏情况下，dfs会遍历整个board，每个节点有4个方向可以选择，所以是4的L次方。
空间复杂度：`O(L)`，其中L是word的长度。dfs的递归深度最大为L，所以空间复杂度是O(L)。



📌 [查看 Python 代码](../solutions/python/No_079_单词搜索.py)