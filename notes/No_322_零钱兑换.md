# LeetCode No.322 零钱兑换

# 题目链接: https://leetcode.cn/problems/target-sum/description/


## 题目描述
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

## 解题思路
- ** 方法 1 ** ：动态规划一维数组：
一维数组的想法就是把二维压缩了，不存储上一层的数值了，而是用滚动数组，在一个数组中进行更新。
这道题可以转换成完全背包问题。
动态规划五部曲：
1. 确定dp数组以及下标的含义：
dp[j]的定义为：空间为j的时候需要最少dp[j]个硬币.例如：dp[2]的含义是如果背包的容量为2，那么有dp[2]种方式。
2. 确定递推公式：
因为是求最小的硬币组合。所以减去空间，也就是dp[j-coins[i]]就是不放这个硬币最小需要的数量，然后放进去，就是+1.
所以递推公式dp[j] = min(dp[j],dp[j-coins[i]])
3. dp数组如何初始化：
dp[0]初始为0.因为amount为0的时候是0.
因为上面的递推公式是min，所以在初始化的时候就需要注意初始化为inf，如果j-coins[i]是inf那么就说明，这个硬币不能放，所以不改变dp数组
4. 确定遍历顺序：
这个遍历顺序可以先遍历背包或者先遍历物品都可以。
5. 举例推导dp数组:
时间复杂度`O(N^2)` 
空间复杂度：`O(N)` 

📌 [查看 Python 代码](../solutions/python/No_322_零钱兑换.py)