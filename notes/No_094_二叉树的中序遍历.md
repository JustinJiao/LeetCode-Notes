# LeetCode No.94 二叉树的中序遍历

## 题目链接: https://leetcode.cn/problems/binary-tree-inorder-traversal/description/
## 题目描述
给你二叉树的根节点 root ，返回它节点值的 中序 遍历。



## 解题思路
- ** 方法 1 ** ：递归
中序，就是中间节点在中，所以顺序是左中右。
中的方法是:result.append(cur.val)
左的方法是:help(cur.left,result)
右的方法是：help(cur.right,result)
结束条件是当cur为空就要返回去找
时间复杂度`O(N)`  
空间复杂度：`O(N)`

- ** 方法 2 ** ：遍历
中序，就是中间节点在中，所以顺序是左中右。
因为是左中右，所以一开始不能弹出中节点。所以，我们需要一个指针，cur,让它帮我们去寻找。然后stack是存储我们cur遍历过的节点的。
当cur或这stack有一个不为空的时候就可以进入循环。因为cur不为空说明此时还有节点没遍历到，stack不为空，说明有节点还没有被处理也就是加入到result中。
有两种情况，cur为空和不为空
首先：cur不为空的情况下，那么说明这是一个节点，所以需要把这个节点加入到stack中，并且让cur继续向左找
其次：cur不为空的情况下，说明左边没有节点了，那么此时就要弹出一个元素，也就是上一个元素，这个元素就是中，然后将中加入到result中，然后遍历中的右，看看有没有元素。

时间复杂度`O(N)`  
空间复杂度：`O(N)`

- ** 方法 3 ** ：空指针遍历法：
这个方法是一个通用方法对于遍历树来说。
因为前面的方法对于前中后序的遍历来说有些不一样。因为根节点总是先被弹出的。这个方法是尽管弹出了根节点，但又按照顺序把根节点加进去了。但此时注意，要是反过来的压入栈中，因为是先进后出。然后这个其实是通过把遍历和处理分开了，先遍历当前节点，压入栈中。然后因为压入了一个None.所以下次就会变为处理的逻辑，所以就会从中拿到数据。

📌 [查看 Python 代码](../solutions/python/No_094_二叉树的中序遍历.py)